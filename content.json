{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-09-29T09:22:55.145Z","updated":"2024-09-29T09:22:55.126Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"title: 自我介绍 layout: about What is this for ?"},{"title":"tags","date":"2024-09-29T14:17:37.000Z","updated":"2024-09-29T14:17:37.205Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-09-29T14:17:48.000Z","updated":"2024-09-29T14:17:48.517Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"STL中的常用模板","slug":"C-STL常用模板","date":"2024-10-03T10:51:27.000Z","updated":"2024-10-13T08:07:14.526Z","comments":true,"path":"2024/10/03/C-STL常用模板/","permalink":"http://example.com/2024/10/03/C-STL%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"STL中的常用模板及其简易实现 如何能够正确的编写模板 std::declval12template&lt;typename T&gt;add_rvalue_reference_t&lt;T&gt; declval() noexcept; 没有函数体定义，所以并不能独立调用，只可用与模板，decltype，sizeof中用于类型推导，占用内存大小的计算。add_rvalue_reference_t 使用了引用折叠技术。 std::declval不通过构造函数声明一个类型的对象(不是定义一个对象)用于其他的模板技术中。 1234567891011#include &lt;iostream&gt;#include &lt;typeinfo&gt;struct A &#123; int func() &#123; return 0; &#125;&#125;;int main() &#123; decltype(std::declval&lt;A&gt;().func()) num = 0; std::cout &lt;&lt; typeid(num).name() &lt;&lt; std::endl; // i&#125; 这里顺便说一下std::decltype的用法，std::decltype可以通过变量，对象，表达式，函数名，函数指针，但不能是一个类型名。 std::true_type ,std::false_type谨记它们是类型而非像true 和 false这样值。 123456789template&lt;typename T, T v&gt;struct integral_constant &#123; static constexpr T value = v; using value_type = T; using type = integral_constant; &#125;;using true_type = integral_constant&lt;bool, true&gt;;using false_type = integral_constant&lt;bool, false&gt;; 主要用途 用于函数重载的参数placeholder 123456789101112131415161718template&lt;typename T, bool val&gt;struct A &#123; A() &#123; if (val) &#123; std::cout &lt;&lt; &quot;Int constructor\\n&quot;; T data = 10; &#125; else &#123; std::cout &lt;&lt; &quot;String constructor\\n&quot;; T data = &quot;string&quot;; &#125; &#125;&#125;;int main() &#123; A&lt;int, true&gt; i; A&lt;std::string, false&gt; str; return 0;&#125; 会出现编译错误，因为if 和 else 两个分支都会被编译。解决方法可以用 if constexpr (val) 来替代if语句。还可以用下面的方式 123456789101112template&lt;typename T, bool val&gt;struct A &#123; A() &#123; init(integral_const&lt;bool, val&gt;()); &#125; void init(std::true_type) &#123; &#125; void init(std::false_type) &#123; &#125;&#125;; 用于其他bool 型模板的基类 像STL中的std::is_convertible std::is_class …都可以进行值萃取: is_xxx::value std::void_tstd::conditional根据第一个模板参数是否为true，决定使用类型T还是类型U。 定义： 1234567891011121314151617#include &lt;string&gt;template&lt;bool b, typename T, typename U&gt;struct conditional &#123; using type = T;&#125;;template&lt;typename T, typename U&gt;struct conditional&lt;false, T, U&gt; &#123; using type = U;&#125;;int main() &#123; conditional&lt;true, int, std::string&gt;::type i = 10; conditional&lt;false, int, std::string&gt;::type s = &quot;string&quot;; return 0;&#125; std::remove_all_extents用途是去除数组的数组类型只保留元素类型： 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; int a[10] = &#123;0&#125;; std::remove_all_extents&lt;decltype(a)&gt;::type i = 10; // int std::cout &lt;&lt; i &lt;&lt; std::endl; std::remove_all_extents&lt;std::string[10][10]&gt;::type s = &quot;hello&quot;; // string std::cout &lt;&lt; s &lt;&lt; std::endl; return 0;&#125; 它的一种定义如下： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;template&lt;typename T&gt;struct remove_all_extents &#123; using type = T;&#125;;template&lt;typename T, size_t N&gt;struct remove_all_extents&lt;T[N]&gt; &#123; using type = typename remove_all_extents&lt;T&gt;::type;&#125;;template&lt;typename T&gt;struct remove_all_extents&lt;T[]&gt; &#123; using type = typename remove_all_extents&lt;T&gt;::type;;&#125;;int main() &#123; int a[10] = &#123;0&#125;; remove_all_extents&lt;decltype(a)&gt;::type i = 10; // int std::cout &lt;&lt; i &lt;&lt; std::endl; remove_all_extents&lt;std::string[10][10]&gt;::type s = &quot;hello&quot;; // string std::cout &lt;&lt; s &lt;&lt; std::endl; return 0;&#125; std::is_base_of is_union is_classis_copy_assignable其实也是展示declval的使用： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;template&lt;typename T, typename U = std::void_t&lt;&gt;&gt;struct is_copy_assignable : public std::false_type &#123;&#125;;template&lt;typename T&gt;struct is_copy_assignable&lt;T, std::void_t&lt;decltype(std::declval&lt;T&amp;&gt;() = std::declval&lt;const T&amp;&gt;())&gt;&gt; : public std::true_type &#123;&#125;;int main() &#123; std::conditional&lt;is_copy_assignable&lt;std::string&gt;::value, int, std::string&gt;::type data; std::cout &lt;&lt; typeid(data).name() &lt;&lt; std::endl; return 0;&#125; std::integer_sequence这篇文章很不错： https://zhuanlan.zhihu.com/p/679456805 https://www.cnblogs.com/abelian/p/6260951.html 萃取技术萃取有两种： 类型萃取， 传入一种类型，返回另一种类型。形式是 xxx::type 值萃取，传入一种类型，返回一个值。形式是 xxx::value 迭代器萃取STL种有五种迭代器，每种迭代器都有一个tag表明它是哪一种 输出迭代器：struct output_iterator_tag 输入迭代器：struct input_iterator_tag 前向迭代器：struct forward_iterator_tag 双向迭代器：struct bidirectional_iterator_tag 随机迭代器：struct random_access_iterator_tag 迭代器类型萃取如下，也就是利用了每种迭代器中的iterator_category 定义： 12345template&lt;typename It&gt;void display(It iterator) &#123; typename iterator_traits&lt;It&gt;::iterator_category cat; std::cout &lt;&lt; typeid(cat).name() &lt;&lt; std::endl;&#125; iterator_traits 的定义 1234template&lt;typename Iter&gt;struct iterator_traits &#123; using iterator_category = typename Iter::iterator_category;&#125;; 获取容器内元素类型STL中的容器一般都有value_type表示容器内部元素的类型，我们可以利用这个来实现我们的模板类： 123456789101112131415161718#include &lt;typeinfo&gt;#include &lt;iostream&gt;template&lt;typename C&gt;struct EleType &#123; using type = typename C::value_type; &#125;;// For arraytemplate&lt;typename T, size_t N&gt;struct EleType&lt;T[N]&gt; &#123; using type = T;&#125;;int main() &#123; int a[10] = &#123;0&#125;; std::cout &lt;&lt; typeid(EleType&lt;decltype(a)&gt;::type).name() &lt;&lt; std::endl;&#125; std::remove_reference如果传入的是带引用的类型，这个模板类会把引用删除： 1234567891011121314151617181920212223242526272829#include &lt;typeinfo&gt;#include &lt;iostream&gt;// 泛化版本template&lt;typename T&gt;struct remove_reference &#123; using type = T;&#125;;// 特化版本template&lt;typename T&gt;struct remove_reference&lt;T&amp;&gt; &#123; using type = T;&#125;;template&lt;typename T&gt;struct remove_reference&lt;T&amp;&amp;&gt; &#123; using type = T;&#125;;int main() &#123; int a = 10; int &amp;b = a; decltype(b) c = a; std::cout &lt;&lt; &quot;type of c is: &quot; &lt;&lt; typeid(c).name() &lt;&lt; std::endl; remove_reference&lt;decltype(b)&gt;::type d = a; std::cout &lt;&lt; &quot;type of d is: &quot; &lt;&lt; typeid(d).name() &lt;&lt; std::endl; return 0;&#125; std::add_lvalue_reference 和std::add_rvalue_reference用于向类型添加左值和右值引用。还有 std::remove_const 也是类似的实现。 1234567891011// 泛化版本template&lt;typename T&gt;struct remove_const &#123; using type = T;&#125;;template&lt;typename T&gt;struct remove_const&lt;const T&gt; &#123; using type = T;&#125;;... std::decay退化退化就是 把CVR去掉：可以继承 std::remove_const, remove_reference 来实现 把数组，函数当作指针而非引用。这需要针对函数和数组进行模板的特化 然后返回一个类型。 值萃取上面讲的都是类型萃取（传入一个类型，返回一类型），现在我们传入一个类型，返回一个值，这就是值萃取。 STL 中的值萃取大部分都是这种形式：std::is_xxx::value 返回的都是bool is_void判断是不是void 类型 1234567// 泛化版本template&lt;typename T&gt;struct is_void : std::false_type &#123;&#125;;// 特化template&lt;&gt;struct is_void&lt;void&gt; : std::true_type&#123;&#125;; is_same判断两个类型是否相同 1234567// 泛化版本template&lt;typename T1, typename T2&gt;struct is_same : std::false_type &#123;&#125;;// 特化template&lt;typename T&gt;struct is_same&lt;T, T&gt; : std::true_type&#123;&#125;; is_default_constructibleSFINEA来啦，还记得吗？匹配失败的话编译器会退而求其次找别的模板，如果所有的模板都匹配失败，那才报错。 123456789101112131415161718#include &lt;string&gt;#include &lt;iostream&gt;// C++17template&lt;typename T, typename = std::void_t&lt;&gt;&gt;struct is_default_constructible : std::false_type&#123;&#125;;template&lt;typename T&gt;struct is_default_constructible&lt;T, std::void_t&lt;decltype(T())&gt;&gt; : std::true_type &#123;&#125;;struct A &#123;A(int i) &#123;&#125;&#125;;int main() &#123; std::cout &lt;&lt; is_default_constructible&lt;std::string&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; is_default_constructible&lt;A&gt;::value &lt;&lt; std::endl; // 0 return 0;&#125; 还有别的实现方式，比如下面这个展示了模板中函数的运用，另外一种技巧 12345678910111213141516template&lt;typename T&gt;struct is_default_constructible_base &#123;private: template&lt;typename = decltype(T())&gt; static std::true_type test(void*); // 无需实现，因为下面的delctype不需要实际调用 template&lt;typename = int&gt; static std::false_type test(...); public: using type = decltype(test(nullptr)); using value&#125;;template&lt;typename T&gt;struct is_default_constructible : is_default_constructible_base&lt;T&gt;::type&#123;&#125;; is_convertible判断能否将一个类型隐式地转换成另一个类型。 沿用上面提到的使用成员函数的技巧。 convertible就是可以把类型FROM直接赋值给类型TO，这里我们可以写一个函数，形参类型为TO，传入的实参类型为FROM 12345678910111213141516template&lt;typename FROM, typename TO&gt;struct is_convertible_base &#123; static void assign(TO); template&lt;typename = decltype(assign(std::declval(FROM)))&gt; static std::true_type test(void*); template&lt;typename = int&gt; static std::false_type test(...); using type = decltype(test(nullptr));&#125;;template&lt;typename FROM, typename TO&gt;struct is_convertible : is_convertible_base&lt;FROM, TO&gt;::type &#123;&#125;; is_base_of判断一个类型是不是另一个类型的基类 std::is_based_of&lt;Base, Derived&gt; 123456789101112131415161718192021222324252627282930313233#include &lt;typeinfo&gt;#include &lt;string&gt;#include &lt;iostream&gt;template&lt;typename Base, typename Derived&gt;struct is_base_of &#123; template&lt;typename T&gt; static std::true_type test(T*); template&lt;typename&gt; static std::false_type test(void*); template&lt;typename B, typename D&gt; static auto test_i() -&gt; decltype(test&lt;B&gt;(static_cast&lt;D*&gt;(nullptr))); static constexpr bool value = std::is_same&lt; std::integral_constant&lt;bool, std::is_class_v&lt;Base&gt; &amp;&amp; std::is_class_v&lt;Derived&gt; &amp;&amp; decltype(test_i&lt;Base, Derived&gt;())::value&gt;, std::integral_constant&lt;bool, true&gt;&gt;::value;&#125;;struct A &#123;&#125;;struct B : A &#123;&#125;;int main() &#123; std::cout &lt;&lt; is_base_of&lt;B, A&gt;::value &lt;&lt; std::endl; // 0 std::cout &lt;&lt; is_base_of&lt;A, B&gt;::value &lt;&lt; std::endl; // 1 return 0;&#125; 算法萃取（策略模板）传入一个类型，萃取出一个方法（策略）被别的类使用。 这更像是一种静态的多态技术，根据模板参数的不同，执行不同的具体逻辑。这在排序中已经广泛使用： template&lt;typename RandomIter, typename Comp&gt; std::sort(RandomIter first, RandomIter end, Comp comp); 这里的Comp 模板参数就像是一种比较策略，我们可以外部实现不同的比较策略传给sort，sort就会有不同的行为，比如 std::less， std::greater","categories":[],"tags":[{"name":"C++ 模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++ 模板元编程","slug":"C-模板元编程","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"C++ 惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"}]},{"title":"C++惯用法Idioms","slug":"C-惯用法Idioms","date":"2024-10-01T06:01:12.000Z","updated":"2024-10-03T10:28:30.424Z","comments":true,"path":"2024/10/01/C-惯用法Idioms/","permalink":"http://example.com/2024/10/01/C-%E6%83%AF%E7%94%A8%E6%B3%95Idioms/","excerpt":"","text":"[TOC] 下面的惯用法掌握之后可以提高代码的复用性，扩展性，性能，请大家先有模板基础再量力而行。 CRTP用于实现静态多态，在基类中访问子类的数据。实现上就是子类继承于一个模板基类，并把子类作为基类的模板参数。下面这个例子实现了一个单例模式，所有继承自Singleton的类都是单例的, say_hello的存在只是为了展示如何在Base中访问Derived的方法。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;template&lt;typename T&gt;class Singleton &#123; public: static T* instance() &#123; static T inst; return &amp;inst; &#125; void say_hello() &#123; static_cast&lt;T*&gt;(this)-&gt;say_hello(); &#125; protected: Singleton() &#123; std::cout &lt;&lt; &quot;I am base\\n&quot;; &#125;&#125;;class Derived : public Singleton&lt;Derived&gt; &#123; public: Derived() &#123; std::cout &lt;&lt; &quot;I am derived\\n&quot;; &#125; void say_hello() &#123; std::cout &lt;&lt; &quot;Hello, I am derived\\n&quot;; &#125;&#125;;int main() &#123; Derived::instance()-&gt;say_hello();&#125; CRTP的另外用途是可以将逻辑尽量保持在基类当中，子类仅实现必要的逻辑，比如下面这个排序策略 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;template&lt;typename T&gt;struct Sorter &#123; void sort(std::vector&lt;int&gt;&amp; vec) &#123; std::sort(vec.begin(), vec.end(), [this](int lhs, int rhs) &#123; return static_cast&lt;T*&gt;(this)-&gt;cmp(lhs, rhs); &#125;); &#125;&#125;;struct Less : public Sorter&lt;Less&gt; &#123; bool cmp(int lhs, int rhs) &#123; return lhs &lt; rhs; &#125;&#125;;struct Greater : public Sorter&lt;Greater&gt; &#123; bool cmp(int lhs, int rhs) &#123; return lhs &gt; rhs; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; vec = &#123;6,3,5,1,4,2&#125;; Less less; less.sort(vec); // 1, 2, 3, 4, 5, 6, std::for_each(vec.begin(), vec.end(), [](int e) &#123; std:: cout &lt;&lt; e &lt;&lt; &quot;, &quot;;&#125;); std::cout &lt;&lt; std::endl; Greater greater; greater.sort(vec); // 6, 5, 4, 3, 2, 1, std::for_each(vec.begin(), vec.end(), [](int e) &#123; std:: cout &lt;&lt; e &lt;&lt; &quot;, &quot;;&#125;); std::cout &lt;&lt; std::endl; return 0;&#125; Non-Virtual Interface (NVI) Idiom将接口与实现分离：接口为public非virtual，实现为private virtual，一般一个实现只被一个接口调用来避免FBC（Fragile Base Class）问题。形式如下： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;class Base &#123; public: void interface() &#123; return interface_impl(); &#125; private: virtual void interface_impl() &#123; std::cout &lt;&lt; &quot;base impl\\n&quot;; &#125;&#125;;class Derived : public Base &#123; private: void interface_impl() override &#123; std::cout &lt;&lt; &quot;derived impl\\n&quot;; &#125;&#125;;int main() &#123; Base *b = new Derived(); b-&gt;interface(); // derived impl return 0;&#125; Virtual constructor并不是真的虚构造（拷贝）函数，因为C++不支持virtual 构造函数。 这个惯用法是不需要了解具体类型，使用基类指针调用接口来拷贝或创建一个新的子类对象。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;memory&gt;struct Base &#123; virtual std::unique_ptr&lt;Base&gt; create() = 0; virtual std::unique_ptr&lt;Base&gt; clone() = 0; virtual ~Base() = default; virtual void do_it() = 0;&#125;;struct Derived : public Base &#123; std::unique_ptr&lt;Base&gt; create() override &#123; return std::make_unique&lt;Derived&gt;(); &#125; std::unique_ptr&lt;Base&gt; clone() override &#123; return std::make_unique&lt;Derived&gt;(*this); &#125; void do_it() override &#123; std::cout &lt;&lt; &quot;I am Derived_1\\n&quot;; &#125;&#125;;struct Client &#123; std::unique_ptr&lt;Base&gt; instance_; Client(std::unique_ptr&lt;Base&gt; ins) : instance_(std::move(ins)) &#123;&#125; Client(const Client&amp; cli) : instance_(cli.instance_-&gt;clone()) &#123;&#125; void do_it() &#123; instance_-&gt;do_it(); &#125;&#125;;int main() &#123; Client cli(std::make_unique&lt;Derived&gt;()); cli.do_it(); Client cli2(cli); cli2.do_it(); return 0;&#125; Mixins混入是一种将继承的基类设计成模板，从而可以获得基类的数据作为自己的一部分来构造出不同用途的具体类型。 比如游戏当中有很多角色：正常玩家(NormalRole), NPC (NPCRole), VIP玩家(VIPRole)，这些玩家有不同的属性，一般情况下我们用继承的方式来构造这些角色, 每一种角色都有自己特有的属性。 1234567891011121314151617181920212223242526struct Role &#123;&#125;;struct NormalRole : public Role &#123; struct NormalRoleAttr &#123; int life_; int weapons_; &#125;; NormalRoleAttr attr;&#125;;struct NPCRole : public Role &#123; struct NPCRoleAttr &#123; int life_; &#125;; NPCRoleAttr attr;&#125;;struct VIPRole : public Role &#123; struct VIPRoleAttr &#123; int life_; int weapons_; int vip_level_; &#125;; VIPRoleAttr attr;&#125;; 而混入则是将那些特殊属性作为基类，让Role来继承，从而构造出有不同属性的Role： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;struct NormalRoleAttr &#123; int life_ = 100; int weapons_;&#125;;struct NPCRoleAttr &#123; int life_ = 10;&#125;;struct VIPRoleAttr &#123; int vip_level_ = 2;&#125;;template&lt;typename... T&gt;struct Role : public T... &#123;&#125;;using NormalRole = Role&lt;NormalRoleAttr&gt;;using NPCRole = Role&lt;NPCRoleAttr&gt;;using VIPRole = Role&lt;VIPRoleAttr, NormalRoleAttr&gt;; // 两个基类int main() &#123; VIPRole role; std::cout &lt;&lt; role.vip_level_ &lt;&lt; std::endl; return 0;&#125; PIMP一般C++会对外暴露头文件以便让用户查看公共接口，公共接口的实现可能以来一些数据结构，并不想暴露给用户，这个时候PIMP可以允许将数据的实现放在源文件里面，而在头文件里面只有一个指向实现的指针： 12345678910111213141516171819202122232425262728/* public.h */struct Public &#123; Public(); ~Public(); void do_it(); struct Impl; std::unique_ptr&lt;Impl&gt; impl_;&#125;;/* public.cc */struct Public::Impl &#123; void do_it() &#123; std::cout &lt;&lt; &quot;impl: do it\\n&quot;; &#125;&#125;;Public::Public(): impl_(std::make_unique&lt;Impl&gt;()) &#123;&#125;Public::~Public() &#123;&#125;void Public::do_it() &#123; impl-&gt;do_it();&#125;/* main.cc */int main() &#123; Public p; p.do_it(); return 0;&#125; 上面的实现有个潜在的性能问题，涉及到了Impl 的动态内存分配和释放，不完美。 性能较好的是提前分配好Impl需要的内存，使用placement new 来构造impl_ 12345678910struct Public &#123; ... static constexpr std::size_t size = 1024; std::aligned_storage&lt;size, std::alignment_of&lt;std::max_align_t&gt;::value&gt;::type impl;&#125;;Public::Public() &#123; static_assert(sizeof(impl_) &gt;= sizeof(Impl)); new(&amp;impl_) Impl;&#125; Copy and Swap当一个对象不可避免的也被拷贝时，要求我们必须正确的实现拷贝赋值函数，既然有了拷贝赋值函数你也必须实现拷贝构造函数，这两部分代码基本上是重复的，而且赋值函数要复杂一些。为了安全性和避免代码重复我们使用CAS。 为了使用copy-and-swap，我们需要拷贝构造函数、析构函数以及swap交换函数。 一个交换函数是一个non-throwing函数，用来交换某个类的两个对象，按成员交换。我们可能会试着使用std:swap，但是这不可行。因为std:swap使用自己的拷贝构造函数和拷贝赋值操作符。而我们的目的是定义自己的拷贝赋值操作符。 std::string 是一个典型的可使用cas的场景，其他的类似于string资源管理的类型也最好使用cas： 1234567891011121314151617181920212223242526272829struct String &#123; char* data_; String(const char* s = &quot;&quot;) &#123; data_ = new char[strlen(s) + 1]; strcpy(data_, s); &#125; String(const String&amp; s) &#123; data_ = new char[strlen(s) + 1]; strcpy(data_, s.data_); &#125; friend void swap(String&amp; lhs, String&amp; rhs) noexcept &#123; std::swap(lhs.data_, rhs.data_); &#125;&#125;;void process(String s) &#123; String tmp; swap(tmp, s); std::cout &lt;&lt; tmp &lt;&lt; std::endl;&#125;int main() &#123; String s = &quot;cas&quot;; process(s);&#125; EBO （空基类优化）C++ 中不同的对象地址不同，为了达到这一点，任何对象的大小至少是一个字节，即使是一个空类。 而选择用继承而不是组合的方式可以减少对象的大小： 1234567891011121314struct EB &#123;&#125;;// sizeof(EB) == 1;struct Child &#123; int a; EB eb;&#125;;// sizeof(Child) == 8struct Child : private EB &#123; int a;&#125;;// sizeof (Child) == 4; SOO小对象优化，典型的是SSO(shor string optimization) 和boost里面的small_vector. 1234567891011121314// SSOstruct string &#123; struct large &#123; // sizeof is 24 char* data_; size_t size_; size_t capacity_; &#125;; union &#123; char small_[sizeof(large) / sizeof(char)]; // 最后一个字节表示字符串长度，倒数第二个字节是&#x27;\\0&#x27;,所以最多容纳小字符串长度为22 large l_; &#125;;&#125;； Return Type ResolverC++中可以自定义类型转换操作符： 12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt;struct String &#123; std::string data; String(std::string&amp; s) : data(s) &#123;&#125; String(const char* s) : data(s) &#123;&#125; // 类型转换 operator int() &#123; return std::stoi(data); &#125; operator double() &#123; return std::stod(data); &#125;&#125;;int main() &#123; String s(&quot;123&quot;); int i = s; double d = String(&quot;3.14&quot;); std::cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; std::endl;&#125; 如果把类型转换函数模板化就可以自动推导所需类型了： 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;set&gt;#include &lt;iostream&gt;struct Range &#123; const size_t from_ = 0; const size_t to_ = 0; Range(size_t f, size_t t): from_(f), to_(t) &#123;&#125; template&lt;typename Container&gt; operator Container() &#123; Container container; for (size_t i = from_; i &lt; to_; ++i) &#123; container.insert(container.end(), i); &#125; return container; &#125;&#125;;int main() &#123; std::vector&lt;int&gt; v = Range(0, 10); for (auto i : v) std::cout &lt;&lt; i &lt;&lt; std::endl; std::set&lt;int&gt; s = Range(1,3); for (auto i : s) std::cout &lt;&lt; i &lt;&lt; std::endl; return 0;&#125; Named Parameter Idiom这个Idiom是用来提供代码可读性的，尤其是参数比较多的时候用名字比用位置传参可读性更好 12345678910111213141516#include &lt;string&gt;#include &lt;iostream&gt;struct Options &#123; int a = 0; int b = 0; std::string name;&#125;;void config(Options opt) &#123; std::cout &lt;&lt; opt.a &lt;&lt; &quot;, &quot; &lt;&lt; opt.b &lt;&lt; &quot;, &quot; &lt;&lt; opt.name &lt;&lt; std::endl;&#125;int main() &#123; config(&#123;.a = 1, .b = 10, .name = &quot;name&quot;&#125;); return 0;&#125; Methods Chaining在类似于builder模式，std::cout 中就通过返回操作对象的引用来链式的调用函数 下面这个例子实现了类似于Linux命令管道：sort | uniq 1234567891011121314151617181920212223242526272829303132#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;struct Processor &#123; std::vector&lt;int&gt; data_; std::map&lt;int, int&gt; count_; Processor(std::vector&lt;int&gt; data) : data_(std::move(data)) &#123;&#125; Processor&amp; sort() &#123; std::sort(data_.begin(), data_.end()); return *this; &#125; Processor&amp; uniq() &#123; for (size_t i = 0; i &lt; data_.size(); ++i) &#123; count_[data_[i]]++; &#125; return *this; &#125; Processor&amp; print() &#123; for (const auto&amp; p : count_) &#123; std::cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; std::endl; &#125; return *this; &#125;&#125;;int main() &#123; Processor processor(&#123;1,3,4,3,2,5,2,6,6,5,5&#125;); processor.sort().uniq().print(); return 0;&#125; 类型擦除类型擦除允许用一个通用的接口使用各种各样的类型，比如std::function 可以接受lambda，函数指针，函数对象等各种可调用对象，std::any std::variant可以接受任意的类型。C语言中的void* 也可以认为是一种通用的类型。类型擦除在C++中可以认为是一种鸭子类型，看起来像，用起来像，拿它就是一只鸭子。实现上没有固定的模式： void*， 模板，union，继承多态都可以用来实现类型擦除。 下面我们先介绍std::any和std::variant的使用 12345678910111213141516171819#include &lt;variant&gt; #include &lt;vector&gt;#include &lt;any&gt;#include &lt;string&gt;#include &lt;iostream&gt;int main() &#123; std::any a; a = 10; std::cout &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; std::endl; a = &quot;hello any&quot;; std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; std::endl; std::variant&lt;int, std::string, char, long&gt; v; v = 10; std::cout &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; v = std::string&#123;&quot;text&quot;&#125;; std::cout &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl;&#125; 至于具体的实现，有固定的套路：公共类不是模板类；有一个基类可以代表所有数据；有一个模板子类保存具体类型和数据。看下面的例子，很美好，但是有内存代价，毕竟每一次使用都有内存的动态分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;struct Any &#123; struct Base&#123;&#125;; template&lt;typename T&gt; struct Inner : Base &#123; Inner(T t) : data_(std::move(t)) &#123;&#125; static void type()&#123;&#125; T data_; &#125;; template&lt;typename T&gt; Any(T t): ptr_(std::make_unique&lt;Inner&lt;T&gt;&gt;(t)), typePtr(&amp;Inner&lt;T&gt;::type) &#123;&#125; template&lt;typename T&gt; const Any&amp; operator=(T t) &#123; ptr_ = std::make_unique&lt;Inner&lt;T&gt;&gt;(t); typePtr = &amp;Inner&lt;T&gt;::type; return *this; &#125; template&lt;typename T&gt; friend T any_cast(const Any&amp; any); std::unique_ptr&lt;Base&gt; ptr_ = nullptr; void(*typePtr)() = nullptr;&#125;;template&lt;typename T&gt;T any_cast(const Any&amp; any) &#123; if (any.typePtr != &amp;Any::Inner&lt;T&gt;::type) &#123; std::cout &lt;&lt; &quot;type not match\\n&quot;; &#125; return static_cast&lt;Any::Inner&lt;T&gt;*&gt;(any.ptr_.get())-&gt;data_;&#125;int main() &#123; int a = 10; Any any(a); std::cout &lt;&lt; any_cast&lt;int&gt;(any) &lt;&lt; std::endl; any = std::string(&quot;nihao&quot;); std::cout &lt;&lt; any_cast&lt;std::string&gt;(any) &lt;&lt; std::endl; return 0;&#125; SFINAE模板匹配失败不是一个错误！编译器会尝试寻找其他匹配的模板，如果都不匹配才会报错。 SFINAE是模板编程中非常重要的原则，在后面的文章中经常用到，大家一定要搞清楚！ std::enable_if 与SFINEA息息相关，模板元编程中重度使用！后面的文章也会用到！ 下面先举一个简单的例子判断一个类型中是不是含有名字叫Inner的内嵌类 123456789101112131415161718#include &lt;iostream&gt;template&lt;typename T, typename U = void&gt; // C++17 以后可以用std::void_t&lt;&gt; 很好用struct has_inner: std::false_type &#123;&#125;;template&lt;typename T&gt;struct has_inner&lt;T, typename T::Inner&gt; : std::true_type &#123;&#125;;int main() &#123; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; has_inner&lt;int&gt;::value &lt;&lt; std::endl; struct A &#123; struct Inner &#123;&#125;; &#125;; std::cout &lt;&lt; &quot;A: &quot; &lt;&lt; has_inner&lt;A&gt;::value &lt;&lt; std::endl; return 0;&#125; 使用SFINAE 编程的套路：先定义一个泛化版本，在定义一个(偏)特化版本，让我们的目标操作命中特化版本，其他的命中泛化版本。 std::void_tstd::void_t是c++17引入的一个模板类型，非常简单，主要用于检测SFINEA中出现的非法类型，上面的例子可以改成用std::void_t std::void_t: 12template&lt;typename T&gt;using void_t = void; 例子改写： 12345template&lt;typename T, typename U = std::void_t&lt;&gt;&gt;struct has_inner: std::false_type &#123;&#125;;template&lt;typename T&gt;struct has_inner&lt;T, std::void_t&lt;typename T::Inner&gt;&gt; : std::true_type &#123;&#125;; std::enable_if作用是根据条件决定是否使用定义的类型，std::enable_if定义非常简单，看过之后对于它的使用就非常明了了。 123456789// 泛化版本template&lt;bool test, typename T = void&gt;struct enable_if &#123;&#125;// 偏特化版本template&lt;typename T&gt;struct enable_if&lt;true, T&gt; &#123; using type = T;&#125;; 照常用上面的has_inner举个例子 1234std::enable_if&lt;has_inner&lt;A&gt;::value, A::Inner&gt;::type inner; // inner的类型是A::Innerstd::enable_if&lt;has_inner&lt;int&gt;::value, int&gt;::type inner; // error ! 因为参数是false，所以没有typestd::enable_if&lt;(3&gt;2), int&gt;::type a; // type is int","categories":[],"tags":[{"name":"C++ 模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++ 惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"},{"name":"C++ idioms","slug":"C-idioms","permalink":"http://example.com/tags/C-idioms/"}]},{"title":"C++ 模板基础","slug":"C-模板","date":"2024-09-29T10:12:12.000Z","updated":"2024-10-01T05:44:55.398Z","comments":true,"path":"2024/09/29/C-模板/","permalink":"http://example.com/2024/09/29/C-%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"模板的定义 函数模板 函数模板的全特化 函数模板的偏特化 类模板 变量模板 别名模板 模板模板参数 变参模板 非类型模板参数 模板函数的重载 当模板遇到构造函数 当模板遇到虚函数 代码组织 Summary 模板的定义函数模板1234template&lt;typename T&gt;T add(T a, T b) &#123; return a + b;&#125; 使用时不必显示指定参数类型，编译器会进行自动推导，至于参数类型推导规则，不需死记硬背，只需记住会根据形参类型cvr和实参cvr类型来决定最终的T是什么，都会符合你的直觉！这有几个例子： void print(const T&amp; param); int a = 10; int &amp;b = a; print(a); print(b) T 都是 int, 这里的param 的语意是 const 引用，推导的时候会保持这一语意。 void print(T param); param 的含义是T类型参数的拷贝，不管传入什么，推导出的类型都不带cvr void print(T&amp;&amp; param); param 是万能引用，能保持传入参数的cvr和左值（右值）性，下面会详细介绍万能引用。 另外有两个特例，传入的是函数和数组会怎么样？ 函数， 如果是 T param, 则是函数指针, 如果是T&amp; param或者T&amp;&amp; param 就是函数引用 void(&amp;)(void) 数组， 如果是 T param, 则是指针, 如果是T&amp; param或者T&amp;&amp; param 就是数组引用 int(&amp;)[10] Question: 如何获得数组的大小 ？template&lt;typename T, size_t N&gt;size_t arr_size(T(&amp;)[N]) { return N; } 函数模板的全特化所谓全特化，就是你来显示的指定模板所用的参数，而不是让编译器去推导，所以模板函数的全特化版本不再需要模板参数，只需要让编译器知道这是一个模板的全特化版本就可以了 123456789101112template&lt;typename T, typename U&gt;void print(T a, U b); // no need to define it if we don&#x27;t use ittemplate&lt;&gt;void print(int a, double b) &#123; printf(&quot;%d, %f\\n&quot;, a, b);&#125;template&lt;&gt;void print&lt;char, char&gt;(char a, char b) &#123;&#125; 函数模板的偏特化函数模板不能偏特化!!! 类模板类模板是有偏特化的，而且偏特化非常有用，在STL中大量使用，这里我们只展示如何写，至于实际的使用放在后面。与函数模板不同，在使用类模板时必须显示指定类型参数 12345678template&lt;typename T, typename U&gt;struct Value &#123; using value_type = T; T value1; U value2;&#125;;Value&lt;int, double&gt; v; 全特化 123456template&lt;&gt;struct Value&lt;int, double&gt; &#123; Value() &#123; printf(&quot;generic\\n&quot;); &#125;&#125;; 偏特化 参数个数的偏特化，例如原来的两个变成一个 参数范围的偏特化，例如原来的T变成T*123456789101112131415// 参数个数template&lt;typename T&gt;struct Value&lt;T, char&gt; &#123; Value() &#123; printf(&quot;specific number\\n&quot;); &#125;&#125;;// 参数范围template&lt;typename T, typename U&gt;struct Value&lt;T, U*&gt; &#123; Value() &#123; printf(&quot;specific scope\\n&quot;); &#125;&#125;; 变量模板这个比较少见，是C++14引入的, 一般这种变量模板需要定义在全局空间或者命名空间中。语法是这样的： 1234567891011template&lt;typename T&gt;T a&#123;&#125;a&lt;int&gt; = 10;a&lt;double&gt; = 10.0;// 也可以这样template &lt;typename T&gt;char c&#123;&#125;;c&lt;int&gt; = &#x27;a&#x27;;c&lt;double&gt; = &#x27;b&#x27;; 上述代码会在全局空间实例化成两个不同类型不同名字的变量 int a 与 double a。 别名模板感谢c++11，现在我们可以给模板起一个名字了 1234template&lt;typename T&gt;using IntMap = std::map&lt;int, T&gt;;IntMap&lt;std::string&gt; m; 模板模板参数假定一个类是一个数据的容器，这个类既可以用list也可以用vector来作为底层的存储容器，那应该怎么写呢？？我们应该让 vector&#x2F;list 作为模板参数，那是否应该这样写呢？ 1234template&lt;typename T, typename C&gt;struct Store &#123; C&lt;T&gt; storage;&#125;; No，问题在于编译器不知道C是一个模板，那么怎么才能让他成为模板呢，显示的告诉编译器就好了：Container 是一个类型，所以用class修饰（c++17可以用typename修饰），Container又是一个模板类还需要添上template修饰，由于这个template里面的参数用不到，所以这里省略了名字。 1234template&lt;typename T, template&lt;typename...&gt; class Container&gt;struct Store &#123; Container&lt;T&gt; storage;&#125;; 变参模板形式: 1234template&lt;typename... Args&gt;void print(Args... args) &#123; printf(&quot;generic version&quot;);&#125; 实际开发中使用变参模板的场景是完美转发，将传入参数原封不动的传递给其他函数。 变参的展开：使用递归的方式展开，如果是变参模板类，可以使用继承递归或者组合递归的方式，无论哪种方式，都需要一个递归终止的条件也就是特化版本： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;template&lt;typename... Args&gt;void print(Args... args); // 不需要定义，因为没有调用这个模板// 偏特化版本template&lt;typename First, typename... Args&gt;void print(First f, Args... args) &#123; printf(&quot;generic: %d\\n&quot;, f); print(args...);&#125;// 特化版本template&lt;&gt;void print() &#123; printf(&quot;specific\\n&quot;);&#125;int main()&#123; print(1,2,3,4,5);&#125;/**** * Output ****/// generic: 1// generic: 2// generic: 3// generic: 4// generic: 5// specific 大家可以思考一下如果是类模板应该怎么展开 ？下面展示了用递归继承的方式进行展开 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;typeinfo&gt;// 主模板定义template&lt;typename... Others&gt;struct A &#123; A() &#123; printf(&quot;generic\\n&quot;); &#125;&#125;;// 偏特化template&lt;typename First, typename... Others&gt;struct A&lt;First, Others...&gt; : private A&lt;Others...&gt; &#123; A() &#123; printf(&quot;specific: %s\\n&quot;, typeid(First).name()); &#125;&#125;;int main()&#123; A&lt;int, double, float, char&gt; a;&#125; 上面的private继承本身有 has-a 的含义，所以其实用递归组合的方式也是一样的 12345678template&lt;typename First, typename... Others&gt;struct A&lt;First, Others...&gt; &#123; A() &#123; printf(&quot;specific: %s\\n&quot;, typeid(First).name()); &#125; A&lt;Others...&gt; a;&#125;; 非类型模板参数只有能准确确定值的常量才能作为模板参数，比如整型，指针值。不能作为模板参数的例子： 全局指针123456789template&lt;const char* p&gt;struct A&#123;&#125;;const char* global_p = &quot;hello tmpl&quot;;A&lt;global_p&gt; a; // Wrongconst char global_arr[] = &quot;hello tmpl&quot;;A&lt;global_arr&gt; b; // Correct 字符串常量 浮点数由于浮点数不精确，无法确定两个类型是否是相同的 模板函数的重载当选择函数时，如果都符合条件，编译器选择的优先顺序是： 普通函数 –&gt; 特化函数 –&gt; 模板函数。 当模板遇到构造函数对于普通的构造函数重载，没什么特殊性，遵循上述的选择顺序即可。但是对于拷贝构造函数 就有点特殊了，很可能与你的直觉不一致，看个例子 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;typeinfo&gt;template&lt;typename U&gt;struct A &#123; template&lt;typename T&gt; A(T i) &#123; printf(&quot;template constructor\\n&quot;); &#125; template&lt;typename T&gt; A(const A&lt;T&gt;&amp; other) &#123; printf(&quot;template copy constructor\\n&quot;); &#125; A(int i) &#123; printf(&quot;normal constructor\\n&quot;); &#125; A(const A&amp;) &#123; printf(&quot;normal copy construtor\\n&quot;); &#125;&#125;;int main()&#123; A&lt;int&gt; a(10); // normal constructor A&lt;int&gt; b(1.0); // template constructor A&lt;int&gt; c(1); // normal constructor A&lt;int&gt; d = c; // normal copy construtor&#125; Note: 拷贝构造函数模板 不是 拷贝构造函数，拷贝赋值函数模板不是拷贝赋值函数，因为拷贝构造函数要求拷贝的对象类型完全相同，而模板则没有这样的要求。 上面的代码中如果把一个A&lt;double&gt; 拷贝给一个A&lt;int&gt;，则会调用模板，因为类型不同 如果把拷贝函数模板中的const去掉，则无论类型是否相同都会调用模板函数，123template&lt;typename T&gt;A(A&lt;T&gt;&amp; other) &#123;&#125; 当模板遇到虚函数 模板函数不能是虚函数在编译期间就要知道虚函数表的大小一边存储所有的虚函数，而模板函数只有在使用的时候才会进行实例化，也就是在所有的编译单元编译完成之前是不能知道有多少个实例的，这样一来要想确认虚函数的个数只有延迟到链接期，除非编译器支持，否则虚函数不能是模板 模板类可以包含虚函数类模板中的函数只有当被调用时才会实例化，但是虚函数一定会被实例化，无论是不是被调用。 代码组织原则就是 在使用模板时，一定要能够看到模板的完整定义，否则会导致链接错误 将模板的声明和定义都放在一个头文件里面。这是最标准的做法 将模板的声明放在头文件，定义放在源文件，但是头文件的最后 #include &quot;tmpl.cc&quot; 如果模板类&#x2F;函数只在一个源文件使用，那可以将定义放在这个源文件里面 特化版本可以放在源文件里面，因为链接的时候可以找到 Summary本文主要讲述了下面的概念和示例： 全特化 偏特化 变参模板 模板模板参数 模板函数重载，尤其是构造函数重载 代码如何组织才能避免链接错误","categories":[],"tags":[{"name":"C++模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"}]},{"title":"second post","slug":"second-post","date":"2024-09-29T09:08:53.000Z","updated":"2024-09-29T09:10:29.888Z","comments":true,"path":"2024/09/29/second-post/","permalink":"http://example.com/2024/09/29/second-post/","excerpt":"","text":"This is my import progress","categories":[],"tags":[{"name":"heelo jhgeng","slug":"heelo-jhgeng","permalink":"http://example.com/tags/heelo-jhgeng/"}]},{"title":"","slug":"second","date":"2024-09-29T09:04:18.165Z","updated":"2024-09-29T09:04:18.165Z","comments":true,"path":"2024/09/29/second/","permalink":"http://example.com/2024/09/29/second/","excerpt":"","text":"This is second posthelloworldgjh","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-09-29T08:31:29.605Z","updated":"2024-09-29T08:31:29.605Z","comments":true,"path":"2024/09/29/hello-world/","permalink":"http://example.com/2024/09/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++ 模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++ 模板元编程","slug":"C-模板元编程","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"C++ 惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"},{"name":"C++ idioms","slug":"C-idioms","permalink":"http://example.com/tags/C-idioms/"},{"name":"C++模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"},{"name":"heelo jhgeng","slug":"heelo-jhgeng","permalink":"http://example.com/tags/heelo-jhgeng/"}]}