{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-09-29T09:22:55.145Z","updated":"2024-09-29T09:22:55.126Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"title: 自我介绍 layout: about What is this for ?"},{"title":"tags","date":"2024-09-29T14:17:37.000Z","updated":"2024-09-29T14:17:37.205Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-09-29T14:17:48.000Z","updated":"2024-09-29T14:17:48.517Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ 模板基础","slug":"C-模板","date":"2024-09-29T10:12:12.000Z","updated":"2024-10-01T05:44:55.398Z","comments":true,"path":"2024/09/29/C-模板/","permalink":"http://example.com/2024/09/29/C-%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"模板的定义 函数模板 函数模板的全特化 函数模板的偏特化 类模板 变量模板 别名模板 模板模板参数 变参模板 非类型模板参数 模板函数的重载 当模板遇到构造函数 当模板遇到虚函数 代码组织 Summary 模板的定义函数模板1234template&lt;typename T&gt;T add(T a, T b) &#123; return a + b;&#125; 使用时不必显示指定参数类型，编译器会进行自动推导，至于参数类型推导规则，不需死记硬背，只需记住会根据形参类型cvr和实参cvr类型来决定最终的T是什么，都会符合你的直觉！这有几个例子： void print(const T&amp; param); int a = 10; int &amp;b = a; print(a); print(b) T 都是 int, 这里的param 的语意是 const 引用，推导的时候会保持这一语意。 void print(T param); param 的含义是T类型参数的拷贝，不管传入什么，推导出的类型都不带cvr void print(T&amp;&amp; param); param 是万能引用，能保持传入参数的cvr和左值（右值）性，下面会详细介绍万能引用。 另外有两个特例，传入的是函数和数组会怎么样？ 函数， 如果是 T param, 则是函数指针, 如果是T&amp; param或者T&amp;&amp; param 就是函数引用 void(&amp;)(void) 数组， 如果是 T param, 则是指针, 如果是T&amp; param或者T&amp;&amp; param 就是数组引用 int(&amp;)[10] Question: 如何获得数组的大小 ？template&lt;typename T, size_t N&gt;size_t arr_size(T(&amp;)[N]) { return N; } 函数模板的全特化所谓全特化，就是你来显示的指定模板所用的参数，而不是让编译器去推导，所以模板函数的全特化版本不再需要模板参数，只需要让编译器知道这是一个模板的全特化版本就可以了 123456789101112template&lt;typename T, typename U&gt;void print(T a, U b); // no need to define it if we don&#x27;t use ittemplate&lt;&gt;void print(int a, double b) &#123; printf(&quot;%d, %f\\n&quot;, a, b);&#125;template&lt;&gt;void print&lt;char, char&gt;(char a, char b) &#123;&#125; 函数模板的偏特化函数模板不能偏特化!!! 类模板类模板是有偏特化的，而且偏特化非常有用，在STL中大量使用，这里我们只展示如何写，至于实际的使用放在后面。与函数模板不同，在使用类模板时必须显示指定类型参数 12345678template&lt;typename T, typename U&gt;struct Value &#123; using value_type = T; T value1; U value2;&#125;;Value&lt;int, double&gt; v; 全特化 123456template&lt;&gt;struct Value&lt;int, double&gt; &#123; Value() &#123; printf(&quot;generic\\n&quot;); &#125;&#125;; 偏特化 参数个数的偏特化，例如原来的两个变成一个 参数范围的偏特化，例如原来的T变成T*123456789101112131415// 参数个数template&lt;typename T&gt;struct Value&lt;T, char&gt; &#123; Value() &#123; printf(&quot;specific number\\n&quot;); &#125;&#125;;// 参数范围template&lt;typename T, typename U&gt;struct Value&lt;T, U*&gt; &#123; Value() &#123; printf(&quot;specific scope\\n&quot;); &#125;&#125;; 变量模板这个比较少见，是C++14引入的, 一般这种变量模板需要定义在全局空间或者命名空间中。语法是这样的： 1234567891011template&lt;typename T&gt;T a&#123;&#125;a&lt;int&gt; = 10;a&lt;double&gt; = 10.0;// 也可以这样template &lt;typename T&gt;char c&#123;&#125;;c&lt;int&gt; = &#x27;a&#x27;;c&lt;double&gt; = &#x27;b&#x27;; 上述代码会在全局空间实例化成两个不同类型不同名字的变量 int a 与 double a。 别名模板感谢c++11，现在我们可以给模板起一个名字了 1234template&lt;typename T&gt;using IntMap = std::map&lt;int, T&gt;;IntMap&lt;std::string&gt; m; 模板模板参数假定一个类是一个数据的容器，这个类既可以用list也可以用vector来作为底层的存储容器，那应该怎么写呢？？我们应该让 vector&#x2F;list 作为模板参数，那是否应该这样写呢？ 1234template&lt;typename T, typename C&gt;struct Store &#123; C&lt;T&gt; storage;&#125;; No，问题在于编译器不知道C是一个模板，那么怎么才能让他成为模板呢，显示的告诉编译器就好了：Container 是一个类型，所以用class修饰（c++17可以用typename修饰），Container又是一个模板类还需要添上template修饰，由于这个template里面的参数用不到，所以这里省略了名字。 1234template&lt;typename T, template&lt;typename...&gt; class Container&gt;struct Store &#123; Container&lt;T&gt; storage;&#125;; 变参模板形式: 1234template&lt;typename... Args&gt;void print(Args... args) &#123; printf(&quot;generic version&quot;);&#125; 实际开发中使用变参模板的场景是完美转发，将传入参数原封不动的传递给其他函数。 变参的展开：使用递归的方式展开，如果是变参模板类，可以使用继承递归或者组合递归的方式，无论哪种方式，都需要一个递归终止的条件也就是特化版本： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;template&lt;typename... Args&gt;void print(Args... args); // 不需要定义，因为没有调用这个模板// 偏特化版本template&lt;typename First, typename... Args&gt;void print(First f, Args... args) &#123; printf(&quot;generic: %d\\n&quot;, f); print(args...);&#125;// 特化版本template&lt;&gt;void print() &#123; printf(&quot;specific\\n&quot;);&#125;int main()&#123; print(1,2,3,4,5);&#125;/**** * Output ****/// generic: 1// generic: 2// generic: 3// generic: 4// generic: 5// specific 大家可以思考一下如果是类模板应该怎么展开 ？下面展示了用递归继承的方式进行展开 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;typeinfo&gt;// 主模板定义template&lt;typename... Others&gt;struct A &#123; A() &#123; printf(&quot;generic\\n&quot;); &#125;&#125;;// 偏特化template&lt;typename First, typename... Others&gt;struct A&lt;First, Others...&gt; : private A&lt;Others...&gt; &#123; A() &#123; printf(&quot;specific: %s\\n&quot;, typeid(First).name()); &#125;&#125;;int main()&#123; A&lt;int, double, float, char&gt; a;&#125; 上面的private继承本身有 has-a 的含义，所以其实用递归组合的方式也是一样的 12345678template&lt;typename First, typename... Others&gt;struct A&lt;First, Others...&gt; &#123; A() &#123; printf(&quot;specific: %s\\n&quot;, typeid(First).name()); &#125; A&lt;Others...&gt; a;&#125;; 非类型模板参数只有能准确确定值的常量才能作为模板参数，比如整型，指针值。不能作为模板参数的例子： 全局指针123456789template&lt;const char* p&gt;struct A&#123;&#125;;const char* global_p = &quot;hello tmpl&quot;;A&lt;global_p&gt; a; // Wrongconst char global_arr[] = &quot;hello tmpl&quot;;A&lt;global_arr&gt; b; // Correct 字符串常量 浮点数由于浮点数不精确，无法确定两个类型是否是相同的 模板函数的重载当选择函数时，如果都符合条件，编译器选择的优先顺序是： 普通函数 –&gt; 特化函数 –&gt; 模板函数。 当模板遇到构造函数对于普通的构造函数重载，没什么特殊性，遵循上述的选择顺序即可。但是对于拷贝构造函数 就有点特殊了，很可能与你的直觉不一致，看个例子 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;typeinfo&gt;template&lt;typename U&gt;struct A &#123; template&lt;typename T&gt; A(T i) &#123; printf(&quot;template constructor\\n&quot;); &#125; template&lt;typename T&gt; A(const A&lt;T&gt;&amp; other) &#123; printf(&quot;template copy constructor\\n&quot;); &#125; A(int i) &#123; printf(&quot;normal constructor\\n&quot;); &#125; A(const A&amp;) &#123; printf(&quot;normal copy construtor\\n&quot;); &#125;&#125;;int main()&#123; A&lt;int&gt; a(10); // normal constructor A&lt;int&gt; b(1.0); // template constructor A&lt;int&gt; c(1); // normal constructor A&lt;int&gt; d = c; // normal copy construtor&#125; Note: 拷贝构造函数模板 不是 拷贝构造函数，拷贝赋值函数模板不是拷贝赋值函数，因为拷贝构造函数要求拷贝的对象类型完全相同，而模板则没有这样的要求。 上面的代码中如果把一个A&lt;double&gt; 拷贝给一个A&lt;int&gt;，则会调用模板，因为类型不同 如果把拷贝函数模板中的const去掉，则无论类型是否相同都会调用模板函数，123template&lt;typename T&gt;A(A&lt;T&gt;&amp; other) &#123;&#125; 当模板遇到虚函数 模板函数不能是虚函数在编译期间就要知道虚函数表的大小一边存储所有的虚函数，而模板函数只有在使用的时候才会进行实例化，也就是在所有的编译单元编译完成之前是不能知道有多少个实例的，这样一来要想确认虚函数的个数只有延迟到链接期，除非编译器支持，否则虚函数不能是模板 模板类可以包含虚函数类模板中的函数只有当被调用时才会实例化，但是虚函数一定会被实例化，无论是不是被调用。 代码组织原则就是 在使用模板时，一定要能够看到模板的完整定义，否则会导致链接错误 将模板的声明和定义都放在一个头文件里面。这是最标准的做法 将模板的声明放在头文件，定义放在源文件，但是头文件的最后 #include &quot;tmpl.cc&quot; 如果模板类&#x2F;函数只在一个源文件使用，那可以将定义放在这个源文件里面 特化版本可以放在源文件里面，因为链接的时候可以找到 Summary本文主要讲述了下面的概念和示例： 全特化 偏特化 变参模板 模板模板参数 模板函数重载，尤其是构造函数重载 代码如何组织才能避免链接错误","categories":[],"tags":[{"name":"C++模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"}]},{"title":"second post","slug":"second-post","date":"2024-09-29T09:08:53.000Z","updated":"2024-09-29T09:10:29.888Z","comments":true,"path":"2024/09/29/second-post/","permalink":"http://example.com/2024/09/29/second-post/","excerpt":"","text":"This is my import progress","categories":[],"tags":[{"name":"heelo jhgeng","slug":"heelo-jhgeng","permalink":"http://example.com/tags/heelo-jhgeng/"}]},{"title":"","slug":"second","date":"2024-09-29T09:04:18.165Z","updated":"2024-09-29T09:04:18.165Z","comments":true,"path":"2024/09/29/second/","permalink":"http://example.com/2024/09/29/second/","excerpt":"","text":"This is second posthelloworldgjh","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-09-29T08:31:29.605Z","updated":"2024-09-29T08:31:29.605Z","comments":true,"path":"2024/09/29/hello-world/","permalink":"http://example.com/2024/09/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++模板","slug":"C-模板","permalink":"http://example.com/tags/C-%E6%A8%A1%E6%9D%BF/"},{"name":"C++惯用法","slug":"C-惯用法","permalink":"http://example.com/tags/C-%E6%83%AF%E7%94%A8%E6%B3%95/"},{"name":"heelo jhgeng","slug":"heelo-jhgeng","permalink":"http://example.com/tags/heelo-jhgeng/"}]}